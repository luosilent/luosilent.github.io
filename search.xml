<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F23%2F%E6%AF%8F%E6%97%A5%E6%96%87%E5%AD%A6%E9%98%85%E8%AF%BB4%2F</url>
    <content type="text"><![CDATA[title: 每天读点文学4date: 2017-08-23 09:47:02tags: 文摘categories: 文摘 每天读点文学 If you want something you have never had, you must be willing to do something you have never done. 如果你想得到从未拥有过的东西，你就得去做从未做过的事。 When it comes to family, we are all still children at heart. No matter how old we get,we always need a place to call home. 面对家人的时候，在我们内心深处我们始终觉得自己还是孩子。不管我们年龄多大了，我们还需要一个称之为家的地方。 ​​​​​]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django知识点整理]]></title>
    <url>%2F2017%2F08%2F23%2FDjango%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是web框架框架，即framework，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，使用框架可以帮你快速开发特定的系统，简单地说，就是你用别人搭建好的舞台来做表演。 web应用访问请求流程 *浏览器发送一个HTTP请求； *服务器收到请求，生成一个HTML文档（待补充；是否是全部类型的访问都需要生成文档）； *服务器把HTML文档作为HTTP响应的Body发送给浏览器； *浏览器收到HTTP响应，从HTTP Body取出HTML文档并解析显示 对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。 socket实例 # -*- coding: utf-8 -*- # @Date : 2016/11/24 # @Author : Jesson import socket def handle_request(client): buf = client.recv(1024) client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;.encode(&quot;utf8&quot;)) client.send(&quot;&lt;h1 style=&apos;color:#1b7665&apos;&gt;Hello, Jesson&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)) def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind((&apos;localhost&apos;,8001)) sock.listen(5) whileTrue: connection, address = sock.accept() handle_request(connection) connection.close() if __name__ ==&apos;__main__&apos;: main()&lt;/pre&gt; 地址栏输入访问请求： 最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。 这个接口就是WSGI：Web Server Gateway Interface。 WSGI 简单介绍WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。 WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的。 很多框架都自带了 WSGI server ，比如 Flask，webpy，Django、CherryPy等等。当然性能都不好，自带的 web server 更多的是测试用途，发布时则使用生产环境的 WSGI server或者是联合 nginx 做 uwsgi。 通俗来讲，WSGI就像是一座桥梁，一边连着web服务器，另一边连着用户的应用。但是呢，这个桥的功能很弱，有时候还需要别的桥来帮忙才能进行处理。 WSGI的作用WSGI有两方：“服务器”或“网关”一方，以及“应用程序”或“应用框架”一方。服务方调用应用方，提供环境信息，以及一个回调函数（提供给应用程序用来将消息头传递给服务器方），并接收Web内容作为返回值。 所谓的 WSGI中间件同时实现了API的两方，因此可以在WSGI服务和WSGI应用之间起调解作用：从WSGI服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能： 重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。允许在一个进程中同时运行多个应用程序或应用框架。负载均衡和远程处理，通过在网络上转发请求和响应消息。进行内容后处理，例如应用XSLT样式表。WSGI 的设计确实参考了 Java 的 servlet。http://www.python.org/dev/peps/pep-0333/ 有这么一段话： By contrast, although Java has just as many web application frameworks available, Java’s “servlet” API makes it possible for applications written with any Java web application framework to run in any web server that supports the servlet API. 另外，需要提及的一点是：其它基于python的web框架，如tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如tornado用的是自己的异步非阻塞“wsgi”，flask则只提供了最精简和基本的框架。Django则是直接使用了WSGI，并实现了大部分功能。 WSGI实例一 # -*- coding: utf-8 -*- from wsgiref.simple_server import make_server def application(environ, start_response): start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) return[b&apos;&lt;h1 &gt;Hello, web!&lt;/h1&gt;&apos;] #&apos;&apos;中间为空，表示的是本地地址 httpd = make_server(&apos;&apos;,8080, application) print(&apos;Serving HTTP on port 8000...&apos;) # 开始监听HTTP请求: httpd.serve_forever()&lt;/pre&gt; 整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写， 我们只负责在更高层次上考虑如何响应请求就可以了。 application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。 Python内置了一个WSGI服务器，这个模块叫wsgiref application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：//environ：一个包含所有HTTP请求信息的dict对象； //start_response：一个发送HTTP响应的函数。 在application()函数中，调用： start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) 就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次start_response()函数。 start_response()函数接收两个参数，一个是HTTP响应码，一个是一组list表示的HTTP Header，每 个Header用一个包含两个str的tuple表示。 通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。 然后，函数的返回值b&apos;&lt;h1&gt;Hello, web!&lt;/h1&gt;&apos;将作为HTTP响应的Body发送给浏览器。 有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML， 通过start_response()发送Header，最后返回Body。&lt;/pre&gt; WSGI实例二 from wsgiref.simple_server import make_server def f1(): f1=open(&quot;jd_index1.html&quot;,&quot;rb&quot;) data1=f1.read() return[data1] def f2(): f2=open(&quot;tb_index.html&quot;,&quot;rb&quot;) data2=f2.read() return[data2] def application(environ, start_response): print(environ[&apos;PATH_INFO&apos;]) path=environ[&apos;PATH_INFO&apos;] start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) # 如果URL路径为京东,执行函数1，返回京东主页 if path==&quot;/jingdong&quot;: return f1() # 如果URL路径为淘宝，执行函数2，返回淘宝主页 elif path==&quot;/taobao&quot;: return f2() else: return[&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)] httpd = make_server(&apos;&apos;,8810, application) print(&apos;Serving HTTP on port 8810...&apos;) # 开始监听HTTP请求: httpd.serve_forever() 打开浏览器访问相应的路径这里我们WSGI每次修改完数据后，都需要重新启动该服务。 WSGI实例3打印当前时间 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Date : 2016/11/24 # @Author : Jesson import time from wsgiref.simple_server import make_server def f1(req): print(req) print(req[&quot;QUERY_STRING&quot;]) f1=open(&quot;jd_index1.html&quot;,&quot;rb&quot;) data1=f1.read() return[data1] def f2(req): f2=open(&quot;tb_index.html&quot;,&quot;rb&quot;) data2=f2.read() return[data2] def f3(req):#模版以及数据库 f3=open(&quot;current_time.html&quot;,&quot;rb&quot;) data3=f3.read() times=time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()) # 在前端相应的页面 设置自定义模版语言&apos;! !&apos; data3=str(data3,&quot;utf8&quot;).replace(&quot;!time!&quot;,str(times)) return[data3.encode(&quot;utf8&quot;)] def routers(): urlpatterns =( (&apos;/jingdong&apos;,f1), (&apos;/taobao&apos;,f2), (&quot;/cur_time&quot;,f3) ) return urlpatterns def application(environ, start_response): print(environ[&apos;PATH_INFO&apos;]) path=environ[&apos;PATH_INFO&apos;] start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) urlpatterns = routers() func =None for item in urlpatterns: if item[0]== path: func = item[1] break if func: return func(environ) else: return[&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)] httpd = make_server(&apos;&apos;,8828, application) print(&apos;Serving HTTP on port 8828...&apos;) # 开始监听HTTP请求: httpd.serve_forever()&lt;/pre&gt; 其实，上边几个实例就相当于一个简单的web框架。 MVC和MTV设计模式MVC/MTV介绍 MVC百度百科：全名Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 通俗解释：一种文件的组织和管理形式！不要被缩写吓到了，这其实就是把不同类型的文件放到不同的目录下的一种方法，然后取了个高大上的名字。当然，它带来的好处有很多，比如前后端分离，松耦合等等，就不详细说明了。 模型(model)：定义数据库相关的内容，一般放在models.py文件中。 视图(view)：定义HTML等静态网页文件相关，也就是那些html、css、js等前端的东西。 控制器(controller)：定义业务逻辑相关，就是你的主要代码。 MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。 Django的MTV模型组织 在web开发的项目文件中，相关目录分开存放，必须要有机制将他们在内里进行耦合。在Django中，urls、orm、static、settings等起着重要的作用。 一个典型的业务流程是如下图所示： 那么我们学Django学的是什么？ 目录结构规范 urls路由方式 settings配置 ORM操作 模板渲染 其它 Django工作流程和命令行工具基本流程 # Django # 安装： pip3 install django 添加环境变量 #1 创建project工程 django-admin startproject mysite ---mysite ---settings.py ---url.py ---wsgi.py ---manage.py(启动文件) #2 创建APP应用 python mannage.py startapp app01 #3 settings配置 TEMPLATES STATICFILES_DIRS=( os.path.join(BASE_DIR,&quot;statics_自定义&quot;), ) STATIC_URL =&apos;/static/&apos; # 我们只能用 STATIC_URL，但STATIC_URL会按着你的STATICFILES_DIRS去找 &lt;script src=&quot;/statics_自定义/jquery-3.1.1.js&quot;&gt;&lt;/script&gt; ------这么写可以实现，但是不规范－－－－－不能直接用，必须用STATIC_URL =&apos;/static/&apos; &lt;script src=&quot;/static/jquery-3.1.1.js&quot;&gt;&lt;/script&gt; 采用第二种方式，后端的更改不会影响前端的引入，避免造成前端大量修改。 #4 根据需求设计代码 url.py view.py #5 使用模版 render(req,&quot;index.html&quot;) #6 启动项目 python manage.py runserver 127.0.0.1:8090 #7 连接数据库，操作数据 model.py django的命令行工具 django-admin.py 是Django的一个用于管理任务的命令行工具，manage.py是对django－admin.py的简单包装,每一个Django Project里都会有一个mannage.py。 1.创建一个django工程 : django-admin.py startproject mysite当前目录下会生成mysite的工程，目录结构如下： manage.py —-Django项目里面的工具，通过它可以调用django shell和数据库等。 settings.py —包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。 urls.py —-负责把URL模式映射到应用程序。 2.在mysite目录下创建blog应用: python manage.py startapp blog 启动django项目：python manage.py runserver 8080这样我们的django就启动起来了！当我们访问：http://127.0.0.1:8080/时就可以看到：It worked! 生成同步数据库的脚本文件：python manage.py makemigrations同步数据库： python manage.py migrate 注意： 在开发过程中，数据库同步误操作之后，难免会遇到后面不能同步成功的情况，解决这个问题的一个简单粗暴方法是把migrations目录下的脚本（除init.py之外）全部删掉，再把数据库删掉之后创建一个新的数据库，数据库同步操作再重新做一遍。 当我们访问http://127.0.0.1:8080/admin/时，会出现后台管理 所以我们需要为进入这个项目的后台创建超级管理员：python manage.py createsuperuser 终端执行上述命令，设置好用户名和密码后便可登录啦！设置用户名的时候，邮箱email可以不用输入，密码有复杂度校验，设置的复杂点。另外，还会提示你，密码会明文显示。 Warning: Password input may be echoed.OK~ 如此优雅的后台界面！ 清空数据库： python manage.py flush 查询某个命令的详细信息： django-admin.py help startapp admin 是Django 自带的一个后台数据库管理系统。 启动交互界面 ：python manage.py shell 这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。 ######思考题补充：(1) 如何更改正在运行的开发服务器端口 #进入django命令行，执行： python manage.py runserver 加上新的端口号8080 Django URL (路由系统)URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 urlpatterns =[url(正则表达式, views视图函数，参数，别名),] 参数说明： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 URL conf实例 from django.conf.urls import url from django.contrib import admin from app01 import views urlpatterns =[ url(r&apos;^articles/2003/$&apos;, views.special_case_2003), #url(r&apos;^articles/[0-9]{4}/$ &apos;, views.year_archive), url(r&apos;^articles/([0-9]{4})/$&apos;, views.year_archive), #no_named group url(r&apos;^articles/([0-9]{4})/([0-9]{2})/$ &apos;, views.month_archive), url(r&apos;^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$&apos;, views.article_detail), ] Named groups 使用name组 来配置groups python 测试代码 import re ret=re.search(&apos;(?P&lt;id&gt;\d{3})/(?P&lt;name&gt;\w{3})&apos;,&apos;weeew34ttt123/ooo&apos;) print(ret.group()) print(ret.group(&apos;id&apos;)) print(ret.group(&apos;name&apos;)) 输出结果： 123/ooo 123 ooo projects下的urls.py 配置练习： from django.conf.urls import url from.import views urlpatterns =[ # 正则无名函数 url(r&apos;^articles/2003/$&apos;, views.special_case_2003), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/$ &apos;, views.year_archive), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$&apos;, views.month_archive), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;day&gt;[0-9]{2})/$ &apos;, views.article_detail), ] url起别名，功能对比static名称 urls.py配置 ######################## urlpatterns =[ # 起别名 url(r&apos;^index&apos;,views.index,name=&apos;bieming&apos;), url(r&apos;^admin/&apos;, admin.site.urls), ] # views.py文件中 添加index自定义方法 def index(req): if req.method==&apos;POST&apos;: username=req.POST.get(&apos;username&apos;) password=req.POST.get(&apos;password&apos;) # 实际中，是需要从数据库中读取数据，这里为了演示效果，直接写成固定的了。 if username==&apos;jesson&apos;and password==&apos;123&apos;: returnHttpResponse(&quot;登陆成功&quot;) return render(req,&apos;index.html&apos;) # index.html ##################### &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; # 对应urls.py中的name=&apos;bieming&apos; &lt;form action=&quot;{% url 'bieming' %}&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ####################### Django Views（视图函数）http请求中产生两个核心对象：http请求：HttpRequest对象http响应：HttpResponse对象所在位置：django.http 之前我们用到的参数request就是HttpRequest检测方法：isinstance(request,HttpRequest) HttpRequest对象的属性和方法： path： 请求页面的全路径，不包括域名 method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如 if req.method==&quot;GET&quot;: do_something() else if req.method==&quot;POST&quot;: do_something_else() GET: 包含所有HTTP GET参数的类字典对象 POST： 包含所有HTTP POST参数的类字典对象 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==”POST” COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。 FILES： 包含所有上传文件的类字典对象； FILES中的每一个Key都是标签中name属性的值，FILES中的每一个value同时也是一个标准的python字典对象,包含下面三个Keys：filename： 上传文件名，用字符串表示content_type: 上传文件的Content Typecontent： 上传文件的原始内容 user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果 访问用户当前没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登陆：if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware 时该属性才可用 session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 方法 get_full_path(),用来返回包含查询字符串的请求路径。比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123req.path:/index33 HttpResponse对象： 对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。HttpResponse类在django.http.HttpResponse在HttpResponse对象上扩展的常用方法： 页面渲染： render()#推荐使用 render_to_response()#不推荐使用 页面跳转： redirect(“路径”) locals()：可以直接将函数本地作用域中所有的变量传给模板， 补充render和redirect的区别: --------url.py url(r&quot;login&quot;, views.login), url(r&quot;jesson_back&quot;, views.jesson_back), -------views.py def login(req): if req.method==&quot;POST&quot;: if1: # return redirect(&quot;/jesson_back/&quot;) name=&quot;jesson&quot; return render(req,&quot;my backend.html&quot;,locals()) return render(req,&quot;login.html&quot;,locals()) def jesson_back(req): name=&quot;jesson&quot; return render(req,&quot;my backend.html&quot;,locals()) ----------------login.html &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt; &lt;p&gt;姓名&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt; ---------------my backend.html &lt;h1&gt;用户{{ name }}你好!&lt;/h1&gt; 总结: render和redirect的区别: 如果 render的页面需要模板语言渲染,需要的将数据库的数据加载到html,那么所有的这一部分除了写在yuan_back的视图函数中,必须还要写在login中,代码重复,没有解耦.the most important: url没有跳转到/jesson_back/,而是还在/login/,所以当刷新后又得重新登录. 自己构造response]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学3]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%AF%8F%E6%97%A5%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A63%2F</url>
    <content type="text"><![CDATA[每天读点文学 别在树下徘徊，别在雨中沉思，别在黑暗中落泪。向前看，不要回头，只要你勇于面对抬起头来，就会发现，分数的阴霾不过是短暂的雨季。向前看，还有一片明亮的天，不会使人感到彷徨。——莎士比亚 《暴风雨》]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath和css解析]]></title>
    <url>%2F2017%2F08%2F20%2Fxpath%E5%92%8Ccss%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. xpath 简介与语法概要xpath 是 w3c 的一种标准。简单来说就是可以让我们以路径的形式访问 html 网页中的各个元素。其中最主要的两个 为 // 与 /。前者代表 路径下的所有元素， 后者代表路径下的子元素。具体语法如下： 基本语法： question # 选取所有 question 元素的所有子节点 /question #选取根元素 question question/a # 选取 question 元素下所有为 a 的子元素 //div # 选取所有的 div 元素，不论其出现在文档的任何地方 question//div # 选取 question 元素下所有的 div 后代元素 (/ 选取的是直接子元素，这里是所有的后代元素) question//span/text() #选取 question 元素下所有 span 元素中的文本值 question//a/@href #选取 question 元素下所有 a 元素中的 href 属性值。 @ 后面可以是任意属性名，均可以取到值 带有限定性质的语法： /question/div[1] # 选取 question 的第一个 div 子元素。 注意这里第一个是从索引 1 开始的 /question/div[last()] # 选取 question 第最后一个 div 子元素 /question/div[last()-1] # 选取 question 的倒数第二个 div 子元素 //div[@lang] # 选取所有拥有lang 属性的 div 元素 //div[@lang=’eng’] # 选取所有 lang 属性为 eng 的 div 元素 其他语法补充： /div/* # 选取属于 div 元素的所有子节点 //* # 选取所有元素 //div/a | //div/p #选 取所有 div 元素的 a 元素或者 p 元素 //span | //input # 选取文档中所有的 span 和 input 元素 二. css 语法概要熟悉前端的同学对 css 选择器一定不会陌生，比如 jQuery 中通过各种 css 选择器语法进行 DOM 操作等。这里对其语法进行简要的总结，便于复习。 基本查询语法 * # 选取所有节点 #title # 选取 id 为 title 的元素 .col-md # 选取所有 class 包含 col-md 的元素 li a # 选取所有 li 下的 a 元素 ul + p # 选取 ul 后面的第一个 p 元素 div#title &gt; ul # 选取 id 为 title 的 div 的第一个 ul 子元素 ul ~ p # 选取 与 url 相邻的所有 p 元素 span#title ::text # 选取 id 为 title 的 span 元素的文本值 a.link::attr(href) # 选取 class 为 link 的 a 元素的 href 属性值 属性相关查询语法 a[title] # 选取所有有 title 属性的 a 元素 a[href=&apos;http://stackoverflow.com/&apos;] # 选取所有 href 属性为 http://stackoverflow.com/ 的 a 元素 a[href*=&quot;stackoverflow&quot;] # 选取所有 href 属性包含 stackoverflow 的 a 元素 a[href^=&apos;https&apos;] # 选取所有 href 属性值以 https 开头的 a 元素 a[href$=&apos;.jpg&apos;] # 选取所有 href 属性值以 .jpg 为结尾的 a 元素 input[type=radio]:checked # 选择选中的 radio 的元素 其他语法 div:not(.title) # 选取所有 class 不是 title 的 div 元素 li:nth-child(3) # 选取第三个元素 tr:nth-child(2n) # 第偶数个元素]]></content>
      <categories>
        <category>网页解析</category>
      </categories>
      <tags>
        <tag>网页解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫的理论知识储备]]></title>
    <url>%2F2017%2F08%2F18%2F%E7%88%AC%E8%99%AB%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
    <content type="text"><![CDATA[网络爬虫，是一种按照一定的规则，自动地抓取万维网信息的程序或脚本。 爬虫通过网页的链接地址来寻找网页并获取网页内容，再根据网页中其他链接不断循环爬取。 1.浏览网页的过程 浏览网页的过程其实就是浏览器作为一个浏览的“客户端”，向服务器端发送了 一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。 使用统一资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符URL。通过超文本传送协议HTTP来实现万维网上各种连接，使用TCP连接进行可靠的传送。使用超文本标记语言HTML使得网页设计者可以很方便地用链接从本页面的某处链接到任意网页，并在自己主机屏幕上显示。 2.统一资源定位符URLURL是用来表示从因特网上得到的资源位置和访问这些资源的方法。URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL相当于一个文件名在网络范围的扩展。因此，URL是与因特网相连的机器上的任何可访问对象的指针。由于访问不同对象使用的协议不同，URL还能之处读取某个对象时所使用的协议。URL的一般形式为： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议是指用哪种协议获取该万维网文档，如http，ftp；主机是指该网络文档所在主机的域名；端口和路径有时可以省略。对万维网的网点访问使用HTTP协议，HTTP的默认端口号是80，通常可省略。若在省略文件的路径，则URL就指到因特网上的某个主页。如： www.baidu.com。 3.超文本传送协议HTTPHTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。下图给出了万维网的大致工作过程。 HTTP规定在HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII码穿构成的请求和一个“MIME-like”的响应组成，HTTP报文通常都使用TCP连接传送。 HTTP有两类报文：请求报文（从客户向服务器发送请求报文）和响应报文（从服务器到客户的回答）。HTTP请求报文和响应报文都是由三部分组成，两种报文格式的区别就是开始行不同。 开始行 用于区分是请求报文还是响应报文。开始行在两种报文中分别叫请求行和状态行。 首部行 用来说明浏览器或报文主题的一些信息。 实体主体 在请求报文中一般不用该字段，而在响应报文中也可能没有该字段。 请求行只有三个内容，即方法、请求资源URL和HTTP的版本。下表给出了请求报文中常用的几种方法。 方法意义 GET请求读取URL标志的信息 OPTION请求一些选项的信息 HEAD请求读取URL标志信息的首部 POST给服务器添加信息，如注释 PUT在致命的URL下存储一个文档 DELETE删除致命的URL所标志的资源 CONNECT用于代理服务器 GET http://www.bilibili.com/video/douga.html HTTP/1.1 下面是一个请求报文的例子 4.超文本标记语言HTMLHTML指的是超文本标记语言，是使用标记标签来描述网页的。 HTML标签是由尖括号包围的关键词，比如&lt;html&gt;。HTML标签通常是成对出现的，标签对中的第一个标签是开始标签，第二个是结束标签，比如&lt;b&gt;和&lt;/b&gt;。 HTML文档包含HTML标签和纯文本，也称为网页。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。 五个基本的标签 &lt;h1&gt; - &lt;h6&gt;等：定义HTML 标题。 &lt;p&gt;：定义HTML 段落。 &lt;a&gt;：定义HTML 链接。 &lt;img&gt;：定义HTML 图像。 &lt;div&gt; :HTML分组标签，定义文档中的分区或节。 &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;h2&gt;This is a heading&lt;/h2&gt; &lt;h3&gt;This is a heading&lt;/h3&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt; &lt;img src=&quot;w3school.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt; HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。元素的内容是开始标签与结束标签之间的内容。大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素），HTML 文档由嵌套的 HTML 元素构成。如下例包含3个HTML元素。 &lt;html&gt; &lt;body&gt; &lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 属性：HTML 标签可以拥有属性，属性提供了有关 HTML 元素的更多的信息，属性总是以名称/值对的形式出现，比如：name=”value”，属性总是在 HTML 元素的开始标签中规定；属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没有问题。 HTML链接由&lt;a&gt;标签定义，链接的地址在 href 属性中指定： &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;a&gt; 转载于作者：Mr希灵 链接：http://www.jianshu.com/p/0cec67708277]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学2]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%AF%8F%E5%A4%A9%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[每天读点文学 我喜欢回顾，是因为我不喜欢忘记。我总认为，在世间，有些人、有些事、有些时刻似乎都有一种特定的安排，在当时也许不觉得，但是在以后回想起来，却都有一种深意。我有过许多美丽的时刻，实在舍不得将它们忘记。 ——席慕容《透明的哀伤》]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 技巧总结]]></title>
    <url>%2F2017%2F08%2F17%2FPython-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.枚举 - enumerate 可以有参数哦之前我们这样操作： i = 0 for item in iterable: print i, item i += 1 现在我们这样操作： for i, item in enumerate(iterable): print i, item enumerate函数还可以接收第二个参数。就像下面这样： &gt;&gt;&gt;list(enumerate(&apos;abc&apos;)) [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, &apos;c&apos;)] &gt;&gt;&gt; list(enumerate(&apos;abc&apos;, 1)) [(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;)] 2.字典/集合 解析你也许知道如何进行列表解析，但是可能不知道字典/集合解析。它们简单易用且高效。就像下面这个例子： my_dict = {i: i * i for i in xrange(100)} my_set = {i * 15 for i in xrange(100)} # There is only a difference of &apos;:&apos; in both # 两者的区别在于字典推导中有冒号 3.强制浮点除法from __future__ import division result = 1/2 # print(result) # 0.5 4.对Python表达式求值我们都知道eval函数，但是我们知道literal_eval函数么？也许很多人都不知道吧。可以用这种操作： import ast my_list = ast.literal_eval(expr) 来代替以下这种操作： expr = &quot;[1, 2, 3]&quot; my_list = eval(expr) 我相信对于大多数人来说这种形式是第一次看见，但是实际上这个在Python中已经存在很长时间了。 5.字符串/数列 逆序你可以用以下方法快速逆序排列数列： &gt;&gt;&gt; a = [1,2,3,4] &gt;&gt;&gt; a[::-1] [4, 3, 2, 1] # This creates a new reversed list. # If you want to reverse a list in place you can do: a.reverse() 这总方式也同样适用于字符串的逆序： &gt;&gt;&gt; foo = &quot;yasoob&quot; &gt;&gt;&gt; foo[::-1] &apos;boosay&apos; 6.三元运算三元运算是if-else 语句的快捷操作，也被称为条件运算。这里有几个例子可以供你参考，它们可以让你的代码更加紧凑，更加美观。 [on_true] if [expression] else [on_false] x, y = 50, 25 small = x if x &lt; y else y 7.Python里面如何拷贝一个对象标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象. import copy new_list = copy.copy(existing_list) 有些时候,你希望对象中的属性也被复制,可以使用deepcopy方法: import copy new_list_of_dicts = copy.deepcopy(existing_list_of_dicts) copy(x) Shallow copy operation on arbitrary Python objects. deepcopy(x, memo=None, _nil=[]) Deep copy operation on arbitrary Python objects. 8.python中如何判断对象相等首先是C#中字符串的==和equal方法。 “==” : 对于内置值类型而言， == 判断两个内存值是否相等。 对于用户自定义的值类型而言(Struct)， == 需要重载，否则不能使用。 对于引用类型而言，默认是同一引用才返回true，但是系统重载了很多引用类型的 == （比如下文提到的string），所以c#中引用类型的比较并不建议使用 ==。 “equals” : 对于值类型而言， 内存相等才返回true。 对于引用类型而言，指向同一个引用才算相等。 但是比较特殊的是字符串String,是一个特殊的引用型类型，在C#语言中，重载了string的equals()方法，使string对象用起来就像是值类型一样。 python中的 == python中的对象包含三要素:id, type, value id 用来标识唯一一个对象，type标识对象的类型，value用来设置对象的值。 is 判断是否是一个对象，使用id来判断的。 == 是判断a对象的值是否是b对象的值，默认调用它的__eq__方法。 9.命名技巧今天阅读代码，发现一个不错的函数命名方式: def request(_argv): 就是把所有的参数前面都加上_下划线，这样你在函数体中，一眼就可以看出那些是局部变量，那些是作为参数传入的，类似把全局变量前面加上g。 10.开发者工具集锦 pydoc： 模块可以根据源代码中的docstrings为任何可导入模块生成格式良好的文档。 doctest模块：该模块可以从源代码或独立文件的例子中抽取出测试用例。 unittest模块：该模块是一个全功能的自动化测试框架，该框架提供了对测试准备(test fixtures), 预定义测试集(predefined test suite)以及测试发现(test discovery)的支持。 trace：模块可以监控Python执行程序的方式，同时生成一个报表来显示程序的每一行执行的次数。这些信息可以用来发现未被自动化测试集所覆盖的程序执行路径，也可以用来研究程序调用图，进而发现模块之间的依赖关系。编写并执行测试可以发现绝大多数程序中的问题，Python使得debug工作变得更加简单，这是因为在大部分情况下，Python都能够将未被处理的错误打印到控制台中，我们称这些错误信息为traceback。如果程序不是在文本控制台中运行的，traceback也能够将错误信息输出到日志文件或是消息对话框中。当标准的traceback无法提供足够的信息时，可以使用cgitb 模块来查看各级栈和源代码上下文中的详细信息，比如局部变量。cgitb模块还能够将这些跟踪信息以HTML的形式输出，用来报告web应用中的错误。 pdb：该模块可以显示出程序在错误产生时的执行路径，同时可以动态地调整对象和代码进行调试。profile, timeit: 开发者可以使用profile以及timit模块来测试程序的速度，找出程序中到底是哪里很慢，进而对这部分代码独立出来进行调优的工作。 compileall: Python程序是通过解释器执行的，解释器的输入是原有程序的字节码编译版本。这个字节码编译版本可以在程序执行时动态地生成，也可以在程序打包的时候就生成。compileall模块可以处理程序打包的事宜，它暴露出了打包相关的接口，该接口能够被安装程序和打包工具用来生成包含模块字节码的文件。同时，在开发环境中，compileall模块也可以用来验证源文件是否包含了语法错误。YAPF：Google开源的Python代码格式化工具。 iPDB: iPDB是一个极好的工具，我已经用它查出了很多匪夷所思的bug。pip install ipdb 安装该工具，然后在你的代码中import ipdb; ipdb.set_trace()，然后你会在你的程序运行时，获得一个很好的交互式提示。它每次执行程序的一行并且检查变量。 pycallgraph: 在一些场合，我使用pycallgraph来追踪性能问题。它可以创建函数调用时间和次数的图表。 objgraph: objgraph对于查找内存泄露非常有用。 转载原文by litaotao https://litaotao.github.io/python-materials]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学1]]></title>
    <url>%2F2017%2F08%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[每天读点文学 不要着急，最好的总会在最不经意的时候出现。那我们要做的就是：怀揣希望去努力，静待美好的出现。————泰戈尔 ​​​​]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
</search>
