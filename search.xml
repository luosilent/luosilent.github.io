<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python面试题]]></title>
    <url>%2F2017%2F08%2F31%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.单引号，双引号，三引号的区别分别阐述3种引号用的场景和区别 1).单引号和双引号主要用来表示字符串 比如: 单引号:’python’ 双引号:”python” 2).三引号 三单引号:’’’python ‘’’,也可以表示字符串一般用来输入多行文本,或者用于大段的注释 三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档 区别: 若你的字符串里面本身包含单引号,必须用双引号 比如:”can’t find the log\n” 2.Python的参数传递是值传递还是引用传递举例说明Python函数参数传递的几种形式，并说明函数传参是值传递还是引用传递 1).Python的参数传递有： 位置参数 默认参数， 可变参数, 关键字参数 2).函数的传值到底是值传递还是引用传递，要分情况 a.不可变参数用值传递： 像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象 b.可变参数是用引用传递的 比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变. 3.什么是lambda函数？它有什么好处?举例说明lambda的用法，并说明用lambda的优点 1).lambda的用法： lambda是匿名函数，用法如下:lambda arg1,arg2..argN:expression using args 2).优点 lambda能和def做同样种类的工作，特别是对于那些逻辑简单的函数，直接用lambda会更简洁，而且省去取函数名的麻烦(给函数取名是个技术活) 4.字符串格式化:%和.format的区别字符串的format函数非常灵活，很强大,可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如:填充，对齐,精度等) 5.Python是如何进行内存管理的1).对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 一个对象分配一个新名称 将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 使用del语句对对象别名显示的销毁 引用超出作用域或被重新赋值 2).垃圾回收 当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 3).内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统: Pymalloc机制：为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 6.写一个函数, 输入一个字符串, 返回倒序排列的结果输入: string_reverse(‘abcdef’), 返回: ‘fedcba’,写出你能想到的多种方法 1).利用字符串本身的翻转 def string_reverse1(text=&apos;abcdef&apos;): return text[::-1] 2).把字符串变成列表，用列表的reverse函数 3).新建一个列表，从后往前取 4).利用双向列表deque中的extendleft函数 5).递归 7.按升序合并如下两个list, 并去除重复的元素list1 = [2, 3, 8, 4, 9, 5, 6] list2 = [5, 6, 10, 17, 11, 2] 1).最简单的方法用set list3=list1+list2 print set(list3) 2).递归 先选一个中间数，然后一边是小的数字，一边是大的数字，然后再循环递归，排完序(是不是想起了c里面的冒泡) 8.以下的代码的输出将是什么? 说出你的答案并解释class Parent(object): x = 1 class Child1(Parent): pass class Child2(Parent): pass print Parent.x, Child1.x, Child2.x Child1.x = 2 print Parent.x, Child1.x, Child2.x Parent.x = 3 print Parent.x, Child1.x, Child2.x &gt;&gt; 1 1 1 1 2 1 3 2 3 解答: 使你困惑或是惊奇的是关于最后一行的输出是 3 2 3 而不是 3 2 1。为什么改变了 Parent.x 的值还会改变 Child2.x 的值，但是同时 Child1.x 值却没有改变？ 这个答案的关键是，在 Python中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到. 首先，在父类中设置 x = 1 会使得类变量 x 在引用该类和其任何子类中的值为 1。这就是因为第一个 print 语句的输出是 1 1 1 然后，如果任何它的子类重写了该值（例如，我们执行语句 Child1.x = 2）该值仅仅在子类中被改变。这就是为什么第二个 print 语句的输出是 1 2 1 最后，如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3 9.下面的代码会不会报错list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] print list[10:] 不会报错，而且会输出一个 []，并且不会导致一个 IndexError 解答: 当试图访问一个超过列表索引值的成员将导致 IndexError（比如访问以上列表的 list[10]）。尽管如此，试图访问一个列表的以超出列表长度数作为开始索引的切片将不会导致 IndexError，并且将仅仅返回一个空列表 一个讨厌的小问题是它会导致出现 bug ，并且这个问题是难以追踪的，因为它在运行时不会引发错误，吐血啊~~ 10.说出下面list1,list2,list3的输出值def extendList(val, list=[]): list.append(val) return list list1 = extendList(10) list2 = extendList(123,[]) list3 = extendList(&apos;a&apos;) print &quot;list1 = %s&quot; % list1 print &quot;list2 = %s&quot; % list2 print &quot;list3 = %s&quot; % list3 &gt;&gt; list1 = [10, &apos;a&apos;] list2 = [123] list3 = [10, &apos;a&apos;] 许多人会错误的认为 list1 应该等于 [10] 以及 list3 应该等于 [‘a’]。认为 list 的参数会在 extendList 每次被调用的时候会被设置成它的默认值 []。 尽管如此，实际发生的事情是，新的默认列表仅仅只在函数被定义时创建一次。随后当 extendList 没有被指定的列表参数调用的时候，其使用的是同一个列表。这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候。 因此，list1 和 list3 是操作的相同的列表。而list2是操作的它创建的独立的列表（通过传递它自己的空列表作为list参数的值） 所以这一点一定要切记切记.下面我们把list置为None就可以避免一些麻烦了 11.写出你认为最Pythonic的代码Pythonic编程风格是Python的一种追求的风格，精髓就是追求直观，简洁而容易读. 下面是一些比较好的例子 1).交互变量 非Pythonic temp = a a = b b = temp pythonic: a,b=b,a2).判断其值真假 name = &apos;Tim&apos; langs = [&apos;AS3&apos;, &apos;Lua&apos;, &apos;C&apos;] info = {&apos;name&apos;: &apos;Tim&apos;, &apos;sex&apos;: &apos;Male&apos;, &apos;age&apos;:23 } 非Pythonic if name != ‘’ and len(langs) &gt; 0 and info != {}: print(‘All True!’)pythonic: if name and langs and info: print(‘All True!’)3).列表推导式 [x for x in range(1,100) if x%2==0] 4).zip创建键值对 keys = [&apos;Name&apos;, &apos;Sex&apos;, &apos;Age&apos;] values = [&apos;Jack&apos;, &apos;Male&apos;, 23] dict(zip(keys,values)) 转载自https://ask.hellobi.com/blog/caoniao_xueyuan/7021]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学5]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%AF%8F%E5%A4%A9%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A65%2F</url>
    <content type="text"><![CDATA[每天读点文学5Youth Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life. Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals. Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust. Whether 60 or 16, there is in every human being’s heart the lure of wonders, the unfailing appetite for what’s next and the joy of the game of living. In the center of your heart and my heart, there is a wireless station; so long as it receives messages of beauty, hope, courage and power from man and from the infinite, so long as you are young. When your aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you’ve grown old, even at 20; but as long as your aerials are up, to catch waves of optimism, there’s hope you may die young at 80. 青春 青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。 青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。 岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。 无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。 一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫技巧]]></title>
    <url>%2F2017%2F08%2F25%2Fpython%E7%88%AC%E8%99%AB%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[总结python爬虫技巧1、基本抓取网页get方法 import urllib2 url = &quot;http://www.baidu.com&quot; respons = urllib2.urlopen(url) print response.read() post方法 import urllib import urllib2 url = &quot;http://abcde.com&quot; form = {&apos;name&apos;:&apos;abc&apos;,&apos;password&apos;:&apos;1234&apos;} form_data = urllib.urlencode(form) request = urllib2.Request(url,form_data) response = urllib2.urlopen(request) print response.read() 2、使用代理IP 在开发爬虫过程中经常会遇到IP被封掉的情况，这时就需要用到代理IP； 在urllib2包中有ProxyHandler类，通过此类可以设置代理访问网页，如下代码片段： import urllib2 proxy = urllib2.ProxyHandler({&apos;http&apos;: &apos;127.0.0.1:8087&apos;}) opener = urllib2.build_opener(proxy) urllib2.install_opener(opener) response = urllib2.urlopen(&apos;http://www.baidu.com&apos;) print response.read() 3、Cookies处理 cookies是某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)，python提供了cookielib模块用于处理cookies，cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源. 代码片段： import urllib2, cookielib cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie_support) urllib2.install_opener(opener) content = urllib2.urlopen(&apos;http://XXXX&apos;).read() 关键在于CookieJar()，它用于管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失，所有过程都不需要单独去操作。 手动添加cookie cookie = &quot;PHPSESSID=91rurfqm2329bopnosfu4fvmu7; kmsign=55d2c12c9b1e3; KMUID=b6Ejc1XSwPq9o756AxnBAg=&quot; request.add_header(&quot;Cookie&quot;, cookie) 4、伪装成浏览器 某些网站反感爬虫的到访，于是对爬虫一律拒绝请求。所以用urllib2直接访问网站经常会出现HTTP Error 403: Forbidden的情况 对有些 header 要特别留意，Server 端会针对这些 header 做检查 1.User-Agent 有些 Server 或 Proxy 会检查该值，用来判断是否是浏览器发起的 Request 2.Content-Type 在使用 REST 接口时，Server 会检查该值，用来确定 HTTP Body 中的内容该怎样解析。 这时可以通过修改http包中的header来实现，代码片段如下： import urllib2 headers = { &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6&apos; } request = urllib2.Request( url = &apos;http://my.oschina.net/jhao104/blog?catalog=3463517&apos;, headers = headers ) print urllib2.urlopen(request).read() 5、页面解析 对于页面解析最强大的当然是正则表达式，这个对于不同网站不同的使用者都不一样，就不用过多的说明，附两个比较好的网址： 正则表达式入门：http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html 正则表达式在线测试：http://tool.oschina.net/regex/ 其次就是解析库了，常用的有两个lxml和BeautifulSoup，对于这两个的使用介绍两个比较好的网站： lxml：http://my.oschina.net/jhao104/blog/639448 BeautifulSoup：http://cuiqingcai.com/1319.html 对于这两个库，我的评价是，都是HTML/XML的处理库，Beautifulsoup纯python实现，效率低，但是功能实用，比如能用通过结果搜索获得某个HTML节点的源码；lxmlC语言编码，高效，支持Xpath 6、验证码的处理对于一些简单的验证码，可以进行简单的识别。本人也只进行过一些简单的验证码识别。但是有些反人类的验证码，比如12306，可以通过打码平台进行人工打码，当然这是要付费的。 7、gzip压缩 有没有遇到过某些网页，不论怎么转码都是一团乱码。哈哈，那说明你还不知道许多web服务具有发送压缩数据的能力，这可以将网络线路上传输的大量数据消减 60% 以上。这尤其适用于 XML web 服务，因为 XML 数据 的压缩率可以很高。 但是一般服务器不会为你发送压缩数据，除非你告诉服务器你可以处理压缩数据。 于是需要这样修改代码： import urllib2, httplib request = urllib2.Request(&apos;http://xxxx.com&apos;) request.add_header(&apos;Accept-encoding&apos;, &apos;gzip&apos;) 1 opener = urllib2.build_opener() f = opener.open(request) 这是关键:创建Request对象，添加一个 Accept-encoding 头信息告诉服务器你能接受 gzip 压缩数据 然后就是解压缩数据： import StringIO import gzip compresseddata = f.read() compressedstream = StringIO.StringIO(compresseddata) gzipper = gzip.GzipFile(fileobj=compressedstream) print gzipper.read() 8、多线程并发抓取 单线程太慢的话，就需要多线程了，这里给个简单的线程池模板 这个程序只是简单地打印了1-10，但是可以看出是并发的。 虽然说python的多线程很鸡肋，但是对于爬虫这种网络频繁型，还是能一定程度提高效率的。 from threading import Thread from Queue import Queue from time import sleep # q是任务队列 #NUM是并发线程总数 #JOBS是有多少任务 q = Queue() NUM = 2 JOBS = 10 #具体的处理函数，负责处理单个任务 def do_somthing_using(arguments): print arguments #这个是工作进程，负责不断从队列取数据并处理 def working(): while True: arguments = q.get() do_somthing_using(arguments) sleep(1) q.task_done() #fork NUM个线程等待队列 for i in range(NUM): t = Thread(target=working) t.setDaemon(True) t.start() #把JOBS排入队列 for i in range(JOBS): q.put(i) #等待所有JOBS完成 q.join() 转载原文https://my.oschina.net/jhao104/blog/647308?fromerr=KzH2VGaK]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学4]]></title>
    <url>%2F2017%2F08%2F23%2F%E6%AF%8F%E5%A4%A9%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A64%2F</url>
    <content type="text"><![CDATA[每天读点文学 If you want something you have never had, you must be willing to do something you have never done. 如果你想得到从未拥有过的东西，你就得去做从未做过的事。 When it comes to family, we are all still children at heart. No matter how old we get,we always need a place to call home. 面对家人的时候，在我们内心深处我们始终觉得自己还是孩子。不管我们年龄多大了，我们还需要一个称之为家的地方。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django知识点整理]]></title>
    <url>%2F2017%2F08%2F23%2FDjango%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是web框架框架，即framework，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，使用框架可以帮你快速开发特定的系统，简单地说，就是你用别人搭建好的舞台来做表演。 web应用访问请求流程 *浏览器发送一个HTTP请求； *服务器收到请求，生成一个HTML文档（待补充；是否是全部类型的访问都需要生成文档）； *服务器把HTML文档作为HTTP响应的Body发送给浏览器； *浏览器收到HTTP响应，从HTTP Body取出HTML文档并解析显示 对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。 socket实例 # -*- coding: utf-8 -*- # @Date : 2016/11/24 # @Author : Jesson import socket def handle_request(client): buf = client.recv(1024) client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;.encode(&quot;utf8&quot;)) client.send(&quot;&lt;h1 style=&apos;color:#1b7665&apos;&gt;Hello, Jesson&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)) def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind((&apos;localhost&apos;,8001)) sock.listen(5) whileTrue: connection, address = sock.accept() handle_request(connection) connection.close() if __name__ ==&apos;__main__&apos;: main()&lt;/pre&gt; 地址栏输入访问请求： 最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。 这个接口就是WSGI：Web Server Gateway Interface。 WSGI 简单介绍WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。 WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的。 很多框架都自带了 WSGI server ，比如 Flask，webpy，Django、CherryPy等等。当然性能都不好，自带的 web server 更多的是测试用途，发布时则使用生产环境的 WSGI server或者是联合 nginx 做 uwsgi。 通俗来讲，WSGI就像是一座桥梁，一边连着web服务器，另一边连着用户的应用。但是呢，这个桥的功能很弱，有时候还需要别的桥来帮忙才能进行处理。 WSGI的作用WSGI有两方：“服务器”或“网关”一方，以及“应用程序”或“应用框架”一方。服务方调用应用方，提供环境信息，以及一个回调函数（提供给应用程序用来将消息头传递给服务器方），并接收Web内容作为返回值。 所谓的 WSGI中间件同时实现了API的两方，因此可以在WSGI服务和WSGI应用之间起调解作用：从WSGI服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能： 重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。允许在一个进程中同时运行多个应用程序或应用框架。负载均衡和远程处理，通过在网络上转发请求和响应消息。进行内容后处理，例如应用XSLT样式表。WSGI 的设计确实参考了 Java 的 servlet。http://www.python.org/dev/peps/pep-0333/ 有这么一段话： By contrast, although Java has just as many web application frameworks available, Java’s “servlet” API makes it possible for applications written with any Java web application framework to run in any web server that supports the servlet API. 另外，需要提及的一点是：其它基于python的web框架，如tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如tornado用的是自己的异步非阻塞“wsgi”，flask则只提供了最精简和基本的框架。Django则是直接使用了WSGI，并实现了大部分功能。 WSGI实例一 # -*- coding: utf-8 -*- from wsgiref.simple_server import make_server def application(environ, start_response): start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) return[b&apos;&lt;h1 &gt;Hello, web!&lt;/h1&gt;&apos;] #&apos;&apos;中间为空，表示的是本地地址 httpd = make_server(&apos;&apos;,8080, application) print(&apos;Serving HTTP on port 8000...&apos;) # 开始监听HTTP请求: httpd.serve_forever()&lt;/pre&gt; 整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写， 我们只负责在更高层次上考虑如何响应请求就可以了。 application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。 Python内置了一个WSGI服务器，这个模块叫wsgiref application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：//environ：一个包含所有HTTP请求信息的dict对象； //start_response：一个发送HTTP响应的函数。 在application()函数中，调用： start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) 就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次start_response()函数。 start_response()函数接收两个参数，一个是HTTP响应码，一个是一组list表示的HTTP Header，每 个Header用一个包含两个str的tuple表示。 通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。 然后，函数的返回值b&apos;&lt;h1&gt;Hello, web!&lt;/h1&gt;&apos;将作为HTTP响应的Body发送给浏览器。 有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML， 通过start_response()发送Header，最后返回Body。&lt;/pre&gt; WSGI实例二 from wsgiref.simple_server import make_server def f1(): f1=open(&quot;jd_index1.html&quot;,&quot;rb&quot;) data1=f1.read() return[data1] def f2(): f2=open(&quot;tb_index.html&quot;,&quot;rb&quot;) data2=f2.read() return[data2] def application(environ, start_response): print(environ[&apos;PATH_INFO&apos;]) path=environ[&apos;PATH_INFO&apos;] start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) # 如果URL路径为京东,执行函数1，返回京东主页 if path==&quot;/jingdong&quot;: return f1() # 如果URL路径为淘宝，执行函数2，返回淘宝主页 elif path==&quot;/taobao&quot;: return f2() else: return[&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)] httpd = make_server(&apos;&apos;,8810, application) print(&apos;Serving HTTP on port 8810...&apos;) # 开始监听HTTP请求: httpd.serve_forever() 打开浏览器访问相应的路径这里我们WSGI每次修改完数据后，都需要重新启动该服务。 WSGI实例3打印当前时间 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Date : 2016/11/24 # @Author : Jesson import time from wsgiref.simple_server import make_server def f1(req): print(req) print(req[&quot;QUERY_STRING&quot;]) f1=open(&quot;jd_index1.html&quot;,&quot;rb&quot;) data1=f1.read() return[data1] def f2(req): f2=open(&quot;tb_index.html&quot;,&quot;rb&quot;) data2=f2.read() return[data2] def f3(req):#模版以及数据库 f3=open(&quot;current_time.html&quot;,&quot;rb&quot;) data3=f3.read() times=time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()) # 在前端相应的页面 设置自定义模版语言&apos;! !&apos; data3=str(data3,&quot;utf8&quot;).replace(&quot;!time!&quot;,str(times)) return[data3.encode(&quot;utf8&quot;)] def routers(): urlpatterns =( (&apos;/jingdong&apos;,f1), (&apos;/taobao&apos;,f2), (&quot;/cur_time&quot;,f3) ) return urlpatterns def application(environ, start_response): print(environ[&apos;PATH_INFO&apos;]) path=environ[&apos;PATH_INFO&apos;] start_response(&apos;200 OK&apos;,[(&apos;Content-Type&apos;,&apos;text/html&apos;)]) urlpatterns = routers() func =None for item in urlpatterns: if item[0]== path: func = item[1] break if func: return func(environ) else: return[&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;.encode(&quot;utf8&quot;)] httpd = make_server(&apos;&apos;,8828, application) print(&apos;Serving HTTP on port 8828...&apos;) # 开始监听HTTP请求: httpd.serve_forever()&lt;/pre&gt; 其实，上边几个实例就相当于一个简单的web框架。 MVC和MTV设计模式MVC/MTV介绍 MVC百度百科：全名Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 通俗解释：一种文件的组织和管理形式！不要被缩写吓到了，这其实就是把不同类型的文件放到不同的目录下的一种方法，然后取了个高大上的名字。当然，它带来的好处有很多，比如前后端分离，松耦合等等，就不详细说明了。 模型(model)：定义数据库相关的内容，一般放在models.py文件中。 视图(view)：定义HTML等静态网页文件相关，也就是那些html、css、js等前端的东西。 控制器(controller)：定义业务逻辑相关，就是你的主要代码。 MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。 Django的MTV模型组织 在web开发的项目文件中，相关目录分开存放，必须要有机制将他们在内里进行耦合。在Django中，urls、orm、static、settings等起着重要的作用。 一个典型的业务流程是如下图所示： 那么我们学Django学的是什么？ 目录结构规范 urls路由方式 settings配置 ORM操作 模板渲染 其它 Django工作流程和命令行工具基本流程 # Django # 安装： pip3 install django 添加环境变量 #1 创建project工程 django-admin startproject mysite ---mysite ---settings.py ---url.py ---wsgi.py ---manage.py(启动文件) #2 创建APP应用 python mannage.py startapp app01 #3 settings配置 TEMPLATES STATICFILES_DIRS=( os.path.join(BASE_DIR,&quot;statics_自定义&quot;), ) STATIC_URL =&apos;/static/&apos; # 我们只能用 STATIC_URL，但STATIC_URL会按着你的STATICFILES_DIRS去找 &lt;script src=&quot;/statics_自定义/jquery-3.1.1.js&quot;&gt;&lt;/script&gt; ------这么写可以实现，但是不规范－－－－－不能直接用，必须用STATIC_URL =&apos;/static/&apos; &lt;script src=&quot;/static/jquery-3.1.1.js&quot;&gt;&lt;/script&gt; 采用第二种方式，后端的更改不会影响前端的引入，避免造成前端大量修改。 #4 根据需求设计代码 url.py view.py #5 使用模版 render(req,&quot;index.html&quot;) #6 启动项目 python manage.py runserver 127.0.0.1:8090 #7 连接数据库，操作数据 model.py django的命令行工具 django-admin.py 是Django的一个用于管理任务的命令行工具，manage.py是对django－admin.py的简单包装,每一个Django Project里都会有一个mannage.py。 1.创建一个django工程 : django-admin.py startproject mysite当前目录下会生成mysite的工程，目录结构如下： manage.py —-Django项目里面的工具，通过它可以调用django shell和数据库等。 settings.py —包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。 urls.py —-负责把URL模式映射到应用程序。 2.在mysite目录下创建blog应用: python manage.py startapp blog 启动django项目：python manage.py runserver 8080这样我们的django就启动起来了！当我们访问：http://127.0.0.1:8080/时就可以看到：It worked! 生成同步数据库的脚本文件：python manage.py makemigrations同步数据库： python manage.py migrate 注意： 在开发过程中，数据库同步误操作之后，难免会遇到后面不能同步成功的情况，解决这个问题的一个简单粗暴方法是把migrations目录下的脚本（除init.py之外）全部删掉，再把数据库删掉之后创建一个新的数据库，数据库同步操作再重新做一遍。 当我们访问http://127.0.0.1:8080/admin/时，会出现后台管理 所以我们需要为进入这个项目的后台创建超级管理员：python manage.py createsuperuser 终端执行上述命令，设置好用户名和密码后便可登录啦！设置用户名的时候，邮箱email可以不用输入，密码有复杂度校验，设置的复杂点。另外，还会提示你，密码会明文显示。 Warning: Password input may be echoed.OK~ 如此优雅的后台界面！ 清空数据库： python manage.py flush 查询某个命令的详细信息： django-admin.py help startapp admin 是Django 自带的一个后台数据库管理系统。 启动交互界面 ：python manage.py shell 这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。 ######思考题补充：(1) 如何更改正在运行的开发服务器端口 #进入django命令行，执行： python manage.py runserver 加上新的端口号8080 Django URL (路由系统)URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 urlpatterns =[url(正则表达式, views视图函数，参数，别名),] 参数说明： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 URL conf实例 from django.conf.urls import url from django.contrib import admin from app01 import views urlpatterns =[ url(r&apos;^articles/2003/$&apos;, views.special_case_2003), #url(r&apos;^articles/[0-9]{4}/$ &apos;, views.year_archive), url(r&apos;^articles/([0-9]{4})/$&apos;, views.year_archive), #no_named group url(r&apos;^articles/([0-9]{4})/([0-9]{2})/$ &apos;, views.month_archive), url(r&apos;^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$&apos;, views.article_detail), ] Named groups 使用name组 来配置groups python 测试代码 import re ret=re.search(&apos;(?P&lt;id&gt;\d{3})/(?P&lt;name&gt;\w{3})&apos;,&apos;weeew34ttt123/ooo&apos;) print(ret.group()) print(ret.group(&apos;id&apos;)) print(ret.group(&apos;name&apos;)) 输出结果： 123/ooo 123 ooo projects下的urls.py 配置练习： from django.conf.urls import url from.import views urlpatterns =[ # 正则无名函数 url(r&apos;^articles/2003/$&apos;, views.special_case_2003), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/$ &apos;, views.year_archive), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$&apos;, views.month_archive), url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;day&gt;[0-9]{2})/$ &apos;, views.article_detail), ] url起别名，功能对比static名称 urls.py配置 ######################## urlpatterns =[ # 起别名 url(r&apos;^index&apos;,views.index,name=&apos;bieming&apos;), url(r&apos;^admin/&apos;, admin.site.urls), ] # views.py文件中 添加index自定义方法 def index(req): if req.method==&apos;POST&apos;: username=req.POST.get(&apos;username&apos;) password=req.POST.get(&apos;password&apos;) # 实际中，是需要从数据库中读取数据，这里为了演示效果，直接写成固定的了。 if username==&apos;jesson&apos;and password==&apos;123&apos;: returnHttpResponse(&quot;登陆成功&quot;) return render(req,&apos;index.html&apos;) # index.html ##################### &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; # 对应urls.py中的name=&apos;bieming&apos; &lt;form action=&quot;{% url 'bieming' %}&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ####################### Django Views（视图函数）http请求中产生两个核心对象：http请求：HttpRequest对象http响应：HttpResponse对象所在位置：django.http 之前我们用到的参数request就是HttpRequest检测方法：isinstance(request,HttpRequest) HttpRequest对象的属性和方法： path： 请求页面的全路径，不包括域名 method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如 if req.method==&quot;GET&quot;: do_something() else if req.method==&quot;POST&quot;: do_something_else() GET: 包含所有HTTP GET参数的类字典对象 POST： 包含所有HTTP POST参数的类字典对象 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==”POST” COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。 FILES： 包含所有上传文件的类字典对象； FILES中的每一个Key都是标签中name属性的值，FILES中的每一个value同时也是一个标准的python字典对象,包含下面三个Keys：filename： 上传文件名，用字符串表示content_type: 上传文件的Content Typecontent： 上传文件的原始内容 user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果 访问用户当前没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登陆：if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware 时该属性才可用 session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 方法 get_full_path(),用来返回包含查询字符串的请求路径。比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123req.path:/index33 HttpResponse对象： 对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。HttpResponse类在django.http.HttpResponse在HttpResponse对象上扩展的常用方法： 页面渲染： render()#推荐使用 render_to_response()#不推荐使用 页面跳转： redirect(“路径”) locals()：可以直接将函数本地作用域中所有的变量传给模板， 补充render和redirect的区别: --------url.py url(r&quot;login&quot;, views.login), url(r&quot;jesson_back&quot;, views.jesson_back), -------views.py def login(req): if req.method==&quot;POST&quot;: if1: # return redirect(&quot;/jesson_back/&quot;) name=&quot;jesson&quot; return render(req,&quot;my backend.html&quot;,locals()) return render(req,&quot;login.html&quot;,locals()) def jesson_back(req): name=&quot;jesson&quot; return render(req,&quot;my backend.html&quot;,locals()) ----------------login.html &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt; &lt;p&gt;姓名&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt; ---------------my backend.html &lt;h1&gt;用户{{ name }}你好!&lt;/h1&gt; 总结: render和redirect的区别: 如果 render的页面需要模板语言渲染,需要的将数据库的数据加载到html,那么所有的这一部分除了写在yuan_back的视图函数中,必须还要写在login中,代码重复,没有解耦.the most important: url没有跳转到/jesson_back/,而是还在/login/,所以当刷新后又得重新登录. 自己构造response]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学3]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%AF%8F%E6%97%A5%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A63%2F</url>
    <content type="text"><![CDATA[每天读点文学 别在树下徘徊，别在雨中沉思，别在黑暗中落泪。向前看，不要回头，只要你勇于面对抬起头来，就会发现，分数的阴霾不过是短暂的雨季。向前看，还有一片明亮的天，不会使人感到彷徨。——莎士比亚 《暴风雨》]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath和css解析]]></title>
    <url>%2F2017%2F08%2F20%2Fxpath%E5%92%8Ccss%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. xpath 简介与语法概要xpath 是 w3c 的一种标准。简单来说就是可以让我们以路径的形式访问 html 网页中的各个元素。其中最主要的两个 为 // 与 /。前者代表 路径下的所有元素， 后者代表路径下的子元素。具体语法如下： 基本语法： question # 选取所有 question 元素的所有子节点 /question #选取根元素 question question/a # 选取 question 元素下所有为 a 的子元素 //div # 选取所有的 div 元素，不论其出现在文档的任何地方 question//div # 选取 question 元素下所有的 div 后代元素 (/ 选取的是直接子元素，这里是所有的后代元素) question//span/text() #选取 question 元素下所有 span 元素中的文本值 question//a/@href #选取 question 元素下所有 a 元素中的 href 属性值。 @ 后面可以是任意属性名，均可以取到值 带有限定性质的语法： /question/div[1] # 选取 question 的第一个 div 子元素。 注意这里第一个是从索引 1 开始的 /question/div[last()] # 选取 question 第最后一个 div 子元素 /question/div[last()-1] # 选取 question 的倒数第二个 div 子元素 //div[@lang] # 选取所有拥有lang 属性的 div 元素 //div[@lang=’eng’] # 选取所有 lang 属性为 eng 的 div 元素 其他语法补充： /div/* # 选取属于 div 元素的所有子节点 //* # 选取所有元素 //div/a | //div/p #选 取所有 div 元素的 a 元素或者 p 元素 //span | //input # 选取文档中所有的 span 和 input 元素 二. css 语法概要熟悉前端的同学对 css 选择器一定不会陌生，比如 jQuery 中通过各种 css 选择器语法进行 DOM 操作等。这里对其语法进行简要的总结，便于复习。 基本查询语法 * # 选取所有节点 #title # 选取 id 为 title 的元素 .col-md # 选取所有 class 包含 col-md 的元素 li a # 选取所有 li 下的 a 元素 ul + p # 选取 ul 后面的第一个 p 元素 div#title &gt; ul # 选取 id 为 title 的 div 的第一个 ul 子元素 ul ~ p # 选取 与 url 相邻的所有 p 元素 span#title ::text # 选取 id 为 title 的 span 元素的文本值 a.link::attr(href) # 选取 class 为 link 的 a 元素的 href 属性值 属性相关查询语法 a[title] # 选取所有有 title 属性的 a 元素 a[href=&apos;http://stackoverflow.com/&apos;] # 选取所有 href 属性为 http://stackoverflow.com/ 的 a 元素 a[href*=&quot;stackoverflow&quot;] # 选取所有 href 属性包含 stackoverflow 的 a 元素 a[href^=&apos;https&apos;] # 选取所有 href 属性值以 https 开头的 a 元素 a[href$=&apos;.jpg&apos;] # 选取所有 href 属性值以 .jpg 为结尾的 a 元素 input[type=radio]:checked # 选择选中的 radio 的元素 其他语法 div:not(.title) # 选取所有 class 不是 title 的 div 元素 li:nth-child(3) # 选取第三个元素 tr:nth-child(2n) # 第偶数个元素]]></content>
      <categories>
        <category>网页解析</category>
      </categories>
      <tags>
        <tag>网页解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫的理论知识储备]]></title>
    <url>%2F2017%2F08%2F18%2F%E7%88%AC%E8%99%AB%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
    <content type="text"><![CDATA[网络爬虫，是一种按照一定的规则，自动地抓取万维网信息的程序或脚本。 爬虫通过网页的链接地址来寻找网页并获取网页内容，再根据网页中其他链接不断循环爬取。 1.浏览网页的过程 浏览网页的过程其实就是浏览器作为一个浏览的“客户端”，向服务器端发送了 一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。 使用统一资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符URL。通过超文本传送协议HTTP来实现万维网上各种连接，使用TCP连接进行可靠的传送。使用超文本标记语言HTML使得网页设计者可以很方便地用链接从本页面的某处链接到任意网页，并在自己主机屏幕上显示。 2.统一资源定位符URLURL是用来表示从因特网上得到的资源位置和访问这些资源的方法。URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL相当于一个文件名在网络范围的扩展。因此，URL是与因特网相连的机器上的任何可访问对象的指针。由于访问不同对象使用的协议不同，URL还能之处读取某个对象时所使用的协议。URL的一般形式为： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议是指用哪种协议获取该万维网文档，如http，ftp；主机是指该网络文档所在主机的域名；端口和路径有时可以省略。对万维网的网点访问使用HTTP协议，HTTP的默认端口号是80，通常可省略。若在省略文件的路径，则URL就指到因特网上的某个主页。如： www.baidu.com。 3.超文本传送协议HTTPHTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。下图给出了万维网的大致工作过程。 HTTP规定在HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII码穿构成的请求和一个“MIME-like”的响应组成，HTTP报文通常都使用TCP连接传送。 HTTP有两类报文：请求报文（从客户向服务器发送请求报文）和响应报文（从服务器到客户的回答）。HTTP请求报文和响应报文都是由三部分组成，两种报文格式的区别就是开始行不同。 开始行 用于区分是请求报文还是响应报文。开始行在两种报文中分别叫请求行和状态行。 首部行 用来说明浏览器或报文主题的一些信息。 实体主体 在请求报文中一般不用该字段，而在响应报文中也可能没有该字段。 请求行只有三个内容，即方法、请求资源URL和HTTP的版本。下表给出了请求报文中常用的几种方法。 方法意义 GET请求读取URL标志的信息 OPTION请求一些选项的信息 HEAD请求读取URL标志信息的首部 POST给服务器添加信息，如注释 PUT在致命的URL下存储一个文档 DELETE删除致命的URL所标志的资源 CONNECT用于代理服务器 GET http://www.bilibili.com/video/douga.html HTTP/1.1 下面是一个请求报文的例子 4.超文本标记语言HTMLHTML指的是超文本标记语言，是使用标记标签来描述网页的。 HTML标签是由尖括号包围的关键词，比如&lt;html&gt;。HTML标签通常是成对出现的，标签对中的第一个标签是开始标签，第二个是结束标签，比如&lt;b&gt;和&lt;/b&gt;。 HTML文档包含HTML标签和纯文本，也称为网页。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。 五个基本的标签 &lt;h1&gt; - &lt;h6&gt;等：定义HTML 标题。 &lt;p&gt;：定义HTML 段落。 &lt;a&gt;：定义HTML 链接。 &lt;img&gt;：定义HTML 图像。 &lt;div&gt; :HTML分组标签，定义文档中的分区或节。 &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;h2&gt;This is a heading&lt;/h2&gt; &lt;h3&gt;This is a heading&lt;/h3&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt; &lt;img src=&quot;w3school.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt; HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。元素的内容是开始标签与结束标签之间的内容。大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素），HTML 文档由嵌套的 HTML 元素构成。如下例包含3个HTML元素。 &lt;html&gt; &lt;body&gt; &lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 属性：HTML 标签可以拥有属性，属性提供了有关 HTML 元素的更多的信息，属性总是以名称/值对的形式出现，比如：name=”value”，属性总是在 HTML 元素的开始标签中规定；属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没有问题。 HTML链接由&lt;a&gt;标签定义，链接的地址在 href 属性中指定： &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;a&gt; 转载于作者：Mr希灵 链接：http://www.jianshu.com/p/0cec67708277]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学2]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%AF%8F%E5%A4%A9%E8%AF%BB%E7%82%B9%E6%96%87%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[每天读点文学 我喜欢回顾，是因为我不喜欢忘记。我总认为，在世间，有些人、有些事、有些时刻似乎都有一种特定的安排，在当时也许不觉得，但是在以后回想起来，却都有一种深意。我有过许多美丽的时刻，实在舍不得将它们忘记。 ——席慕容《透明的哀伤》]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 技巧总结]]></title>
    <url>%2F2017%2F08%2F17%2FPython-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.枚举 - enumerate 可以有参数哦之前我们这样操作： i = 0 for item in iterable: print i, item i += 1 现在我们这样操作： for i, item in enumerate(iterable): print i, item enumerate函数还可以接收第二个参数。就像下面这样： &gt;&gt;&gt;list(enumerate(&apos;abc&apos;)) [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, &apos;c&apos;)] &gt;&gt;&gt; list(enumerate(&apos;abc&apos;, 1)) [(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;)] 2.字典/集合 解析你也许知道如何进行列表解析，但是可能不知道字典/集合解析。它们简单易用且高效。就像下面这个例子： my_dict = {i: i * i for i in xrange(100)} my_set = {i * 15 for i in xrange(100)} # There is only a difference of &apos;:&apos; in both # 两者的区别在于字典推导中有冒号 3.强制浮点除法from __future__ import division result = 1/2 # print(result) # 0.5 4.对Python表达式求值我们都知道eval函数，但是我们知道literal_eval函数么？也许很多人都不知道吧。可以用这种操作： import ast my_list = ast.literal_eval(expr) 来代替以下这种操作： expr = &quot;[1, 2, 3]&quot; my_list = eval(expr) 我相信对于大多数人来说这种形式是第一次看见，但是实际上这个在Python中已经存在很长时间了。 5.字符串/数列 逆序你可以用以下方法快速逆序排列数列： &gt;&gt;&gt; a = [1,2,3,4] &gt;&gt;&gt; a[::-1] [4, 3, 2, 1] # This creates a new reversed list. # If you want to reverse a list in place you can do: a.reverse() 这总方式也同样适用于字符串的逆序： &gt;&gt;&gt; foo = &quot;yasoob&quot; &gt;&gt;&gt; foo[::-1] &apos;boosay&apos; 6.三元运算三元运算是if-else 语句的快捷操作，也被称为条件运算。这里有几个例子可以供你参考，它们可以让你的代码更加紧凑，更加美观。 [on_true] if [expression] else [on_false] x, y = 50, 25 small = x if x &lt; y else y 7.Python里面如何拷贝一个对象标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象. import copy new_list = copy.copy(existing_list) 有些时候,你希望对象中的属性也被复制,可以使用deepcopy方法: import copy new_list_of_dicts = copy.deepcopy(existing_list_of_dicts) copy(x) Shallow copy operation on arbitrary Python objects. deepcopy(x, memo=None, _nil=[]) Deep copy operation on arbitrary Python objects. 8.python中如何判断对象相等首先是C#中字符串的==和equal方法。 “==” : 对于内置值类型而言， == 判断两个内存值是否相等。 对于用户自定义的值类型而言(Struct)， == 需要重载，否则不能使用。 对于引用类型而言，默认是同一引用才返回true，但是系统重载了很多引用类型的 == （比如下文提到的string），所以c#中引用类型的比较并不建议使用 ==。 “equals” : 对于值类型而言， 内存相等才返回true。 对于引用类型而言，指向同一个引用才算相等。 但是比较特殊的是字符串String,是一个特殊的引用型类型，在C#语言中，重载了string的equals()方法，使string对象用起来就像是值类型一样。 python中的 == python中的对象包含三要素:id, type, value id 用来标识唯一一个对象，type标识对象的类型，value用来设置对象的值。 is 判断是否是一个对象，使用id来判断的。 == 是判断a对象的值是否是b对象的值，默认调用它的__eq__方法。 9.命名技巧今天阅读代码，发现一个不错的函数命名方式: def request(_argv): 就是把所有的参数前面都加上_下划线，这样你在函数体中，一眼就可以看出那些是局部变量，那些是作为参数传入的，类似把全局变量前面加上g。 10.开发者工具集锦 pydoc： 模块可以根据源代码中的docstrings为任何可导入模块生成格式良好的文档。 doctest模块：该模块可以从源代码或独立文件的例子中抽取出测试用例。 unittest模块：该模块是一个全功能的自动化测试框架，该框架提供了对测试准备(test fixtures), 预定义测试集(predefined test suite)以及测试发现(test discovery)的支持。 trace：模块可以监控Python执行程序的方式，同时生成一个报表来显示程序的每一行执行的次数。这些信息可以用来发现未被自动化测试集所覆盖的程序执行路径，也可以用来研究程序调用图，进而发现模块之间的依赖关系。编写并执行测试可以发现绝大多数程序中的问题，Python使得debug工作变得更加简单，这是因为在大部分情况下，Python都能够将未被处理的错误打印到控制台中，我们称这些错误信息为traceback。如果程序不是在文本控制台中运行的，traceback也能够将错误信息输出到日志文件或是消息对话框中。当标准的traceback无法提供足够的信息时，可以使用cgitb 模块来查看各级栈和源代码上下文中的详细信息，比如局部变量。cgitb模块还能够将这些跟踪信息以HTML的形式输出，用来报告web应用中的错误。 pdb：该模块可以显示出程序在错误产生时的执行路径，同时可以动态地调整对象和代码进行调试。profile, timeit: 开发者可以使用profile以及timit模块来测试程序的速度，找出程序中到底是哪里很慢，进而对这部分代码独立出来进行调优的工作。 compileall: Python程序是通过解释器执行的，解释器的输入是原有程序的字节码编译版本。这个字节码编译版本可以在程序执行时动态地生成，也可以在程序打包的时候就生成。compileall模块可以处理程序打包的事宜，它暴露出了打包相关的接口，该接口能够被安装程序和打包工具用来生成包含模块字节码的文件。同时，在开发环境中，compileall模块也可以用来验证源文件是否包含了语法错误。YAPF：Google开源的Python代码格式化工具。 iPDB: iPDB是一个极好的工具，我已经用它查出了很多匪夷所思的bug。pip install ipdb 安装该工具，然后在你的代码中import ipdb; ipdb.set_trace()，然后你会在你的程序运行时，获得一个很好的交互式提示。它每次执行程序的一行并且检查变量。 pycallgraph: 在一些场合，我使用pycallgraph来追踪性能问题。它可以创建函数调用时间和次数的图表。 objgraph: objgraph对于查找内存泄露非常有用。 转载原文by litaotao https://litaotao.github.io/python-materials]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天读点文学1]]></title>
    <url>%2F2017%2F08%2F16%2Ffirst%2F</url>
    <content type="text"><![CDATA[每天读点文学 不要着急，最好的总会在最不经意的时候出现。那我们要做的就是：怀揣希望去努力，静待美好的出现。————泰戈尔 ​​​​]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
      </tags>
  </entry>
</search>
